import numpy as np
from functools import reduce

from .base import GateGroup,Gate
from qulab_toolbox.wavedata import *


class cliffordGroup(GateGroup):
    """docstring for cliffordGroup."""
    # clifford门的矩阵表示
    matrixlist_clifford_singlequbit=np.array([
        [ [  1,  0] , [  0, 1] ],
        [ [  0,-1j] , [-1j, 0] ],
        [ [  0, -1] , [  1, 0] ],
        [ [-1j,  0] , [  0,1j] ],

        [ [1/np.sqrt(2), -1j/np.sqrt(2)] , [-1j/np.sqrt(2), 1/np.sqrt(2)] ],
        [ [1/np.sqrt(2),  1j/np.sqrt(2)] , [ 1j/np.sqrt(2), 1/np.sqrt(2)] ],
        [ [1/np.sqrt(2),  -1/np.sqrt(2)] , [  1/np.sqrt(2), 1/np.sqrt(2)] ],
        [ [1/np.sqrt(2),   1/np.sqrt(2)] , [ -1/np.sqrt(2), 1/np.sqrt(2)] ],
        [ [1/np.sqrt(2)-1j/np.sqrt(2),0] , [0,1/np.sqrt(2)+1j/np.sqrt(2)] ],
        [ [1/np.sqrt(2)+1j/np.sqrt(2),0] , [0,1/np.sqrt(2)-1j/np.sqrt(2)] ],

        [ [-1j/np.sqrt(2),-1j/np.sqrt(2)] , [-1j/np.sqrt(2), 1j/np.sqrt(2)] ],
        [ [ 1j/np.sqrt(2),-1j/np.sqrt(2)] , [-1j/np.sqrt(2),-1j/np.sqrt(2)] ],
        [ [-1j/np.sqrt(2), -1/np.sqrt(2)] , [  1/np.sqrt(2), 1j/np.sqrt(2)] ],
        [ [ 1j/np.sqrt(2), -1/np.sqrt(2)] , [  1/np.sqrt(2),-1j/np.sqrt(2)] ],
        [ [0,-1/np.sqrt(2)-1j/np.sqrt(2)] , [1/np.sqrt(2)-1j/np.sqrt(2), 0] ],
        [ [0,-1/np.sqrt(2)+1j/np.sqrt(2)] , [1/np.sqrt(2)+1j/np.sqrt(2), 0] ],

        [ [ 0.5-0.5j, -0.5-0.5j ],  [  0.5-0.5j,  0.5+0.5j ] ],
        [ [ 0.5+0.5j, -0.5+0.5j ],  [  0.5+0.5j,  0.5-0.5j ] ],
        [ [ 0.5+0.5j,  0.5-0.5j ],  [ -0.5-0.5j,  0.5-0.5j ] ],
        [ [ 0.5-0.5j,  0.5+0.5j ],  [ -0.5+0.5j,  0.5+0.5j ] ],
        [ [ 0.5-0.5j,  0.5-0.5j ],  [ -0.5-0.5j,  0.5+0.5j ] ],
        [ [ 0.5+0.5j,  0.5+0.5j ],  [ -0.5+0.5j,  0.5-0.5j ] ],
        [ [ 0.5+0.5j, -0.5-0.5j ],  [  0.5-0.5j,  0.5-0.5j ] ],
        [ [ 0.5-0.5j, -0.5+0.5j ],  [  0.5+0.5j,  0.5+0.5j ] ],
    ])
    # 分解的索引
    indexlist_clifford_singlequbit=[
                            ['I'],
                            ['X'],
                            ['Y'],
                            ['Y','X'],

                            ['X2p'],
                            ['X2n'],
                            ['Y2p'],
                            ['Y2n'],
                            ['X2n','Y2p','X2p'],
                            ['X2n','Y2n','X2p'],

                            ['X','Y2n'],
                            ['X','Y2p'],
                            ['Y','X2p'],
                            ['Y','X2n'],
                            ['X2p','Y2p','X2p'],
                            ['X2n','Y2p','X2n'],

                            ['Y2p','X2p'],
                            ['Y2p','X2n'],
                            ['Y2n','X2p'],
                            ['Y2n','X2n'],
                            ['X2p','Y2n'],
                            ['X2n','Y2n'],
                            ['X2p','Y2p'],
                            ['X2n','Y2p'],
                        ]
    # namelist 为序号
    namelist_clifford_singlequbit=[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23]

    def __init__(self):
        self.namelist = self.namelist_clifford_singlequbit
        self.indexlist = self.indexlist_clifford_singlequbit
        self.matrixlist = list(self.matrixlist_clifford_singlequbit) #需要转化为列表格式

    @staticmethod
    def matrix_compare(a, b, phase=True):
        '''比较a,b两个矩阵是否相等'''
        if phase: # 考虑不同相位
            result=any([np.where(abs(f*a-b)<1e-5, True, False).all() for f in [1,-1,1j,-1j]])
        else:
            result=np.where(abs(a-b)<1e-5, True, False).all()
        return result

    def find_index(self, a):
        '''查找a矩阵在matrixlist中的索引序号'''
        for i,v in enumerate(self.matrixlist):
            if self.matrix_compare(a, v, phase=True):
                return i

    def rbm_seq(self,size,group=None):
        '''随机RBM的波形序列'''
        #group 是要随机Clifford门的序号列表
        if group is None:
            group = self.namelist
        # i_r = [group[idx] for idx in np.random.randint(len(group), size=int(size))]
        i_r=list(np.random.choice(group,size=int(size)))
        mat=reduce(np.dot, [self.matrixlist[i] for i in reversed(i_r)])
        mat_inv=np.array(np.matrix(mat).H)
        inv_index=self.find_index(mat_inv)
        i_r.append(inv_index)
        index_seq=reduce(np.append,[self.indexlist[i] for i in i_r])
        return index_seq

    def check_seq(self, seq):
        '''check the sequence generated by rbm_seq, ensure the sequence product identity matrix !'''
        index={'I':0, 'X':1, 'Y':2, 'X2p':4, 'X2n':5, 'Y2p':6, 'Y2n':7}
        idxs=[index[i] for i in seq]
        check_mat=reduce(np.dot,[self.matrixlist[i] for i in reversed(idxs)])
        res = self.matrix_compare(check_mat,self.matrixlist[0],phase=True)
        return res

    @staticmethod
    def gen_XY_by_index(index, pi_len, half_pi_len, pi_factor, half_pi_factor, sRate, TYPE=Gaussian2):
        '''通过给定的参数和索引，产生相应的波形脉冲；
        index : I/X/Y/X2p/X2n/Y2p/Y2n
        TYPE : 为由 width，sRate 两个参数决定的Wavedata类波形，参考Wavedata模块(如: DC,Gaussian,Gaussian2,CosPulse)
        '''
        if len(index)==1:
                if index=='I':
                    pulse_wd_I=Blank(pi_len,sRate)
                    pulse_wd_Q=Blank(pi_len,sRate)
                elif index=='X':
                    pulse_wd_I=pi_factor*TYPE(pi_len,sRate)
                    pulse_wd_Q=Blank(pi_len,sRate)
                elif index=='Y':
                    pulse_wd_I=Blank(pi_len,sRate)
                    pulse_wd_Q=pi_factor*TYPE(pi_len,sRate)
        else:
                if index[0]=='X':
                    if index[2]=='p':
                        pulse_wd_I=half_pi_factor*TYPE(half_pi_len,sRate)
                        pulse_wd_Q=Blank(half_pi_len,sRate)
                    else:
                        pulse_wd_I=-half_pi_factor*TYPE(half_pi_len,sRate)
                        pulse_wd_Q=Blank(half_pi_len,sRate)
                elif index[0]=='Y':
                    if index[2]=='p':
                        pulse_wd_I=Blank(half_pi_len,sRate)
                        pulse_wd_Q=half_pi_factor*TYPE(half_pi_len,sRate)
                    else:
                        pulse_wd_I=Blank(half_pi_len,sRate)
                        pulse_wd_Q=-half_pi_factor*TYPE(half_pi_len,sRate)
        return pulse_wd_I, pulse_wd_Q
